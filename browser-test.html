<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Test - AVAILABILITY Puzzle</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #f5f5f5; }
        .console { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin: 10px 0; }
        .error { color: #d32f2f; }
        .success { color: #388e3c; }
        .warning { color: #f57c00; }
        .info { color: #1976d2; }
        pre { background: #f9f9f9; padding: 10px; border-radius: 4px; overflow-x: auto; }
        button { background: #1976d2; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #1565c0; }
    </style>
</head>
<body>
    <h1>AVAILABILITY Puzzle - Browser Test</h1>
    
    <div class="console">
        <h2>Test Actions</h2>
        <button onclick="testDataLoading()">Test Data Loading</button>
        <button onclick="testAvailabilityPuzzle()">Test AVAILABILITY Puzzle</button>
        <button onclick="simulateGameLoad()">Simulate Game Load</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>
    
    <div id="results"></div>
    
    <!-- Load the game files -->
    <script src="src/data/words-database-compact.js"></script>
    <script src="src/data/common-words.js"></script>
    <script src="src/data/common-definitions.js"></script>
    <script src="src/data/seed-words.js"></script>
    
    <script>
        const results = document.getElementById('results');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `console ${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            results.appendChild(div);
            console.log(message);
        }
        
        function clearResults() {
            results.innerHTML = '';
        }
        
        function testDataLoading() {
            log('=== Testing Data Loading ===');
            
            const checks = [
                { name: 'SEED_WORDS', obj: window.SEED_WORDS },
                { name: 'CORNERSTONE_WORDS_SET', obj: window.CORNERSTONE_WORDS_SET },
                { name: 'COMPREHENSIVE_WORD_SET', obj: window.COMPREHENSIVE_WORD_SET },
                { name: 'COMMON_DEFINITIONS', obj: window.COMMON_DEFINITIONS }
            ];
            
            checks.forEach(check => {
                if (check.obj) {
                    const size = check.obj.size || Object.keys(check.obj).length;
                    log(`‚úÖ ${check.name}: Loaded (${size} items)`, 'success');
                } else {
                    log(`‚ùå ${check.name}: NOT LOADED`, 'error');
                }
            });
            
            // Test AVAILABILITY seed specifically
            if (window.SEED_WORDS && window.SEED_WORDS.AVAILABILITY) {
                log(`‚úÖ AVAILABILITY seed word found: "${window.SEED_WORDS.AVAILABILITY.word}"`, 'success');
            } else {
                log(`‚ùå AVAILABILITY seed word missing`, 'error');
            }
        }
        
        function testAvailabilityPuzzle() {
            log('=== Testing AVAILABILITY Puzzle Logic ===');
            
            if (!window.CORNERSTONE_WORDS_SET || !window.COMPREHENSIVE_WORD_SET) {
                log('‚ùå Required word sets not loaded', 'error');
                return;
            }
            
            // Simulate grid generation for AVAILABILITY
            const HAMILTONIAN_PATHS = [
                [1, 5, 4, 8, 9, 13, 14, 10, 6, 2, 7, 11],  // Path 0
                [4, 5, 9, 8, 13, 14, 11, 7, 6, 10, 2, 1],  // Path 1 - AVAILABILITY
            ];
            
            const seedWord = 'AVAILABILITY';
            const pathIndex = 1;
            const path = HAMILTONIAN_PATHS[pathIndex];
            const grid = Array(16).fill('');
            
            // Place letters along the Hamiltonian path
            for (let i = 0; i < seedWord.length && i < path.length; i++) {
                grid[path[i]] = seedWord[i];
            }
            
            log(`Grid generated for AVAILABILITY:`, 'info');
            log(`<pre>${formatGrid(grid)}</pre>`);
            
            // Test specific words that should be found
            const testWords = ['AVAILABILITY', 'ABILITY', 'BALI', 'AVAIL', 'TAIL'];
            
            testWords.forEach(word => {
                const inComprehensive = window.COMPREHENSIVE_WORD_SET.has(word.toUpperCase());
                const inCommon = window.CORNERSTONE_WORDS_SET.has(word.toLowerCase());
                const canForm = canFormWord(grid, word);
                
                let status = '';
                if (canForm && inCommon) {
                    status = 'üéØ CORNERSTONE WORD';
                } else if (canForm && inComprehensive) {
                    status = 'üìù REGULAR WORD';
                } else if (canForm) {
                    status = '‚ùì FOUND BUT NOT IN DICTIONARY';
                } else {
                    status = '‚ùå CANNOT FORM';
                }
                
                log(`${word.padEnd(12)} | ${status} | Form:${canForm} | Common:${inCommon} | Dict:${inComprehensive}`, 
                    canForm && inCommon ? 'success' : canForm ? 'warning' : 'error');
            });
            
            // Count potential cornerstone words
            const potentialWords = ['AVAILABILITY', 'ABILITY', 'BALI', 'AVAIL', 'BAIL', 'VIAL', 'LAVA'];
            let cornerstoneCount = 0;
            
            potentialWords.forEach(word => {
                if (canFormWord(grid, word) && window.CORNERSTONE_WORDS_SET.has(word.toLowerCase())) {
                    cornerstoneCount++;
                }
            });
            
            log(`<br><strong>Summary: ${cornerstoneCount} cornerstone words should be available</strong>`, 
                cornerstoneCount > 0 ? 'success' : 'error');
        }
        
        function simulateGameLoad() {
            log('=== Simulating Game Load Process ===');
            
            // This simulates what happens in the actual game
            if (!window.CORNERSTONE_WORDS_SET) {
                log('‚ùå CORNERSTONE_WORDS_SET not loaded! Game cannot determine cornerstone words.', 'error');
                return;
            }
            
            log(`‚úÖ CORNERSTONE_WORDS_SET loaded with ${window.CORNERSTONE_WORDS_SET.size} words`, 'success');
            
            // Simulate the findAllPossibleWords process
            const mockFoundWords = ['AVAILABILITY', 'ABILITY', 'BALI', 'AVAIL', 'BAIL', 'LAVA', 'VIAL'];
            const cornerstone = [];
            const regular = [];
            
            mockFoundWords.forEach(word => {
                const isCommon = window.CORNERSTONE_WORDS_SET.has(word.toLowerCase());
                if (isCommon) {
                    cornerstone.push(word);
                } else {
                    regular.push(word);
                }
            });
            
            log(`Classified words:`, 'info');
            log(`- Cornerstone: ${cornerstone.join(', ')}`, 'success');
            log(`- Regular: ${regular.join(', ')}`, 'info');
            
            if (cornerstone.length === 0) {
                log('üö® PROBLEM: No cornerstone words found! This would cause the missing cornerstone words issue.', 'error');
            } else {
                log(`‚úÖ Found ${cornerstone.length} cornerstone words. Puzzle should work correctly.`, 'success');
            }
        }
        
        function formatGrid(grid) {
            let result = '';
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const idx = row * 4 + col;
                    result += (grid[idx] || '.').padEnd(2);
                }
                result += '\\n';
            }
            return result;
        }
        
        function canFormWord(grid, word) {
            // Simple adjacency check - this is a simplified version
            const ADJACENCY = {
                1: [2, 4, 5, 6], 2: [1, 5, 6, 7], 4: [1, 5, 8, 9], 5: [1, 2, 4, 6, 8, 9, 10],
                6: [1, 2, 5, 7, 9, 10, 11], 7: [2, 6, 10, 11], 8: [4, 5, 9, 13],
                9: [4, 5, 6, 8, 10, 13, 14], 10: [5, 6, 7, 9, 11, 13, 14], 11: [6, 7, 10, 14],
                13: [8, 9, 10, 14], 14: [9, 10, 11, 13]
            };
            
            function findPath(targetWord, position, path, used) {
                if (path.length === targetWord.length) {
                    return path.map(p => grid[p]).join('') === targetWord;
                }
                
                const nextChar = targetWord[path.length];
                const neighbors = ADJACENCY[position] || [];
                
                for (const neighbor of neighbors) {
                    if (!used.has(neighbor) && grid[neighbor] === nextChar) {
                        used.add(neighbor);
                        if (findPath(targetWord, neighbor, [...path, neighbor], used)) {
                            return true;
                        }
                        used.delete(neighbor);
                    }
                }
                return false;
            }
            
            // Try starting from each position
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] === word[0]) {
                    const used = new Set([i]);
                    if (findPath(word, i, [i], used)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Auto-run basic test when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('Page loaded. Ready for testing.', 'info');
                testDataLoading();
            }, 500);
        });
    </script>
</body>
</html>