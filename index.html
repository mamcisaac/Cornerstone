<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cornerstones - Daily Word Puzzle</title>
    <!-- Load word validation and definition systems -->
    <script src="words-database-compact.js"></script>
    <script src="common-words.js"></script>
    <script src="common-definitions.js"></script>
    <script src="seed-words.js"></script>
    <script src="hint-system.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            flex: 1;
            max-width: 600px;
        }

        .cornerstone-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .mobile-tabs {
            display: none;
            background: white;
            border-radius: 20px 20px 0 0;
            overflow: hidden;
            margin-bottom: -20px;
        }

        .tab-buttons {
            display: flex;
            background: #f0f0f0;
        }

        .tab-button {
            flex: 1;
            padding: 15px;
            border: none;
            background: transparent;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            max-width: 320px;
            margin: 0 auto 30px auto;
            padding: 20px;
        }

        .cell {
            width: 65px;
            height: 65px;
            border: 3px solid #ddd;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            background: white;
            position: relative;
        }

        .cell:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .cell.empty {
            visibility: hidden;
            pointer-events: none;
        }

        .cell.selected {
            background: #667eea;
            color: white;
            border-color: #5a67d8;
            transform: scale(1.1);
        }

        .cell.in-path {
            background: #e6f3ff;
            border-color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .cornerstone-stat {
            color: #22c55e;
        }

        .current-word {
            text-align: center;
            margin-bottom: 20px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .word-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            letter-spacing: 2px;
        }

        .message {
            text-align: center;
            margin-bottom: 20px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.success {
            color: #4299e1;
            font-weight: bold;
        }

        .message.error {
            color: #ef4444;
            font-weight: bold;
        }

        .message.cornerstone {
            color: #22c55e;
            font-weight: bold;
            font-size: 1.1em;
        }

        .word-display.success {
            color: #4299e1;
            font-weight: bold;
        }

        .word-display.error {
            color: #ef4444;
            font-weight: bold;
        }

        .word-display.cornerstone {
            color: #22c55e;
            font-weight: bold;
            font-size: 1.1em;
        }

        .found-words {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .found-words h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .found-word {
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .found-word.cornerstone {
            background: #48bb78;
        }

        .found-word.regular {
            background: #4299e1;
        }

        .found-word.cornerstone:hover {
            background: #38a169;
            transform: scale(1.05);
        }

        .found-word.regular:hover {
            background: #3182ce;
            transform: scale(1.05);
        }

        .cornerstone-section {
            margin-bottom: 20px;
        }

        .cornerstone-section h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cornerstone-count {
            font-size: 1.2em;
            color: #22c55e;
        }

        .cornerstone-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cornerstone-word {
            background: #f0f0f0;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .cornerstone-word > div:first-child {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cornerstone-word.found {
            background: #22c55e;
            color: white;
        }

        .cornerstone-word-text {
            font-weight: bold;
            font-size: 1.1em;
        }

        .cornerstone-word.hidden .cornerstone-word-text {
            font-family: monospace;
            letter-spacing: 0.3em;
        }

        .word-length {
            font-size: 0.9em;
            color: #666;
            margin-left: 10px;
        }

        .cornerstone-word.found .word-length {
            color: rgba(255, 255, 255, 0.8);
        }

        .word-definition {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            font-style: italic;
            line-height: 1.4;
            display: block;
        }

        .cornerstone-word.found .word-definition {
            color: rgba(255, 255, 255, 0.9);
        }

        .letter-position {
            display: inline-block;
            width: 28px;
            height: 28px;
            text-align: center;
            line-height: 28px;
            margin: 0 2px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            box-sizing: border-box;
            border: 2px solid transparent; /* Default transparent border to match revealed letters */
        }

        .clickable-letter {
            cursor: pointer;
            background: transparent;
            color: #333;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .clickable-letter:hover {
            background: #e6f3ff;
            transform: translateX(3px);
        }

        .clickable-letter:active {
            background: #d1e9ff;
            transform: translateX(1px);
        }

        .revealed-letter {
            color: #666;
            background: #f8f8f8;
            border: 2px solid #ddd;
            /* Removed font-weight: bold to prevent width inconsistency */
            /* .letter-position already has font-weight: bold */
        }
        
        /* Compact letter selection - maintains visual consistency */
        .letter-selection-word {
            background: #f0f8ff;
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #667eea;
        }
        

        .hint-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .hint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .hint-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .hint-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hint-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .hint-button:hover:not(:disabled) {
            background: #5a67d8;
            transform: translateX(5px);
        }

        .hint-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .hint-cost {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .control-button {
            background: #22c55e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin: 0 5px;
        }

        .control-button:hover {
            background: #16a34a;
        }

        .definition-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }

        .definition-popup.show {
            display: block;
        }

        .popup-word {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .popup-definition {
            color: #333;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .popup-type {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }

        .popup-type.cornerstone {
            color: #22c55e;
            font-weight: bold;
        }

        .close-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            float: right;
        }

        .close-btn:hover {
            background: #5a67d8;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .overlay.show {
            display: block;
        }

        /* Hint Options Menu Styles */
        .hint-options-menu {
            position: fixed;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1001;
            display: none;
            min-width: 200px;
        }

        .hint-options-menu.show {
            display: block;
        }

        .hint-options-menu h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 1.1em;
        }

        .hint-option-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .hint-option-button:hover {
            background: #5a67d8;
            transform: translateX(5px);
        }

        .hint-option-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .input-mode-toggle {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .mode-button {
            flex: 1;
            padding: 10px 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .mode-button span {
            display: block;
        }
        
        .mode-button .mode-description {
            font-size: 0.75em;
            color: #666;
            margin-top: 2px;
        }
        
        .mode-button:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .mode-button.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .mode-button.active .mode-description {
            color: #e6eeff;
        }

        .hint-option-cost {
            float: right;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .cornerstone-word.clickable-hint {
            cursor: pointer;
            transition: all 0.2s;
        }

        .cornerstone-word.clickable-hint:hover {
            background: #e6f3ff;
            transform: translateX(5px);
        }
        
        .clickable-letter-global {
            cursor: pointer;
            padding: 2px 4px;
            margin: 0 1px;
            border-radius: 3px;
            transition: all 0.2s;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .clickable-letter-global:hover {
            background: #e6f3ff;
            transform: translateY(-2px);
            border: 1px solid #667eea;
        }
        
        .revealed-letter-global {
            padding: 2px 4px;
            margin: 0 1px;
            border-radius: 3px;
            background: #f8f8f8;
            color: #666;
            border: 1px solid #ddd;
        }

        .help-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            border: none;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .help-button:hover {
            background: #5a67d8;
            transform: scale(1.1);
        }

        .header {
            position: relative;
        }

        .instructions-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            padding-top: 40px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .instructions-close-x {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .instructions-close-x:hover {
            background: #5a67d8;
        }

        .instructions-popup.show {
            display: block;
        }

        .instructions-popup h2 {
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
        }

        .instructions-popup .section {
            margin-bottom: 20px;
        }

        .instructions-popup .section h3 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .instructions-popup ul {
            margin-left: 20px;
            color: #4a5568;
        }

        .instructions-popup li {
            margin-bottom: 8px;
        }

        .close-instructions {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            font-size: 16px;
        }

        .close-instructions:hover {
            background: #5a67d8;
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .cornerstone-panel {
                width: 100%;
                max-width: 600px;
                display: none;
            }

            .mobile-tabs {
                display: block;
                max-width: 600px;
                width: 100%;
                margin: 0 auto 20px;
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }

            .cornerstone-panel.mobile-view {
                display: block;
                box-shadow: none;
                border-radius: 0 0 20px 20px;
                margin-top: -20px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .game-container {
                padding: 20px;
            }
            
            .cell {
                width: 60px;
                height: 60px;
                font-size: 1.5em;
            }
            
            .title {
                font-size: 2em;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .instructions-popup {
                padding: 20px;
                padding-top: 35px;
                width: 95%;
                max-height: 85vh;
                top: 50%;
            }

            .instructions-close-x {
                top: 5px;
                right: 5px;
            }

            .close-instructions {
                padding: 12px 24px;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-tabs">
        <div class="tab-buttons">
            <button class="tab-button active" onclick="switchTab('game')">Game</button>
            <button class="tab-button" onclick="switchTab('cornerstone')">Cornerstone Words</button>
        </div>
    </div>

    <div class="main-container">
        <div class="game-container tab-content active" id="game-tab">
            <div class="header">
                <h1 class="title">Cornerstones</h1>
                <p class="subtitle">Find cornerstone words to win!</p>
                <button class="help-button" onclick="game.showInstructions()" title="How to play">?</button>
            </div>

            <div class="game-grid" id="gameGrid">
                <!-- Grid cells will be generated by JavaScript -->
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value cornerstone-stat" id="cornerstoneFound">0</div>
                    <div class="stat-label">Cornerstone Words</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalFound">0</div>
                    <div class="stat-label">Total Words</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="hintsAvailable">0</div>
                    <div class="stat-label">Hints Available</div>
                </div>
            </div>

            <div class="current-word">
                <div class="word-display" id="currentWord">Select letters to form words</div>
            </div>

            <div class="message" id="message"></div>

            <div class="found-words">
                <h3>Found Words:</h3>
                <div class="word-list" id="wordList"></div>
            </div>

            <div class="controls">
                <button class="control-button" onclick="game.newGame()">New Game</button>
                <button class="control-button" onclick="game.switchPuzzle()">Switch Puzzle</button>
            </div>
        </div>

        <div class="cornerstone-panel tab-content" id="cornerstone-tab">
            <div class="cornerstone-section">
                <h3>
                    Cornerstone Words
                    <span class="cornerstone-count" id="cornerstoneCount">0/0</span>
                </h3>
                <div class="cornerstone-list" id="cornerstoneList">
                    <!-- Cornerstone words will be populated here -->
                </div>
            </div>

            <div class="hint-section">
                <div class="hint-header">
                    <h3>Hints</h3>
                    <span class="hint-count" id="hintCount">0 Available</span>
                </div>
                <div class="hint-actions">
                    <button class="hint-button" id="revealLetterBtn" onclick="game.useHintRevealLetter()">
                        <span>Reveal Letter</span>
                        <span class="hint-cost">1 hint</span>
                    </button>
                    <button class="hint-button" id="showDefinitionBtn" onclick="game.useHintShowDefinition()">
                        <span>Show Definition</span>
                        <span class="hint-cost">1 hint</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="definition-popup" id="definitionPopup">
        <div class="popup-type" id="popupType">Valid Word</div>
        <div class="popup-word" id="popupWord"></div>
        <div class="popup-definition" id="popupDefinition"></div>
        <button class="close-btn" onclick="game.closeDefinition()">Close</button>
    </div>

    <div class="hint-options-menu" id="hintOptionsMenu">
        <h4>Choose Hint Type</h4>
        <button class="hint-option-button" id="hintRevealLetterOption" onclick="if(window.game) window.game.selectHintOption('letter')">
            Reveal a Letter
            <span class="hint-option-cost">1 hint</span>
        </button>
        <button class="hint-option-button" id="hintRevealDefinitionOption" onclick="if(window.game) window.game.selectHintOption('definition')">
            Show Definition
            <span class="hint-option-cost">1 hint</span>
        </button>
    </div>

    <div class="instructions-popup" id="instructionsPopup">
        <button class="instructions-close-x" onclick="game.closeInstructions()" aria-label="Close">×</button>
        <h2>Cornerstones — Quick Guide</h2>
        
        <div class="section">
            <h3>Goal</h3>
            <p>Locate every <strong style="color: #22c55e;">green Cornerstone word</strong> in the grid.</p>
        </div>

        <div class="section">
            <h3>What Counts as a Cornerstone?</h3>
            <p>A <strong>Cornerstone</strong> is any word of <strong>4 or more letters</strong> that ranks within the <strong>10,000 most‑common English words</strong>.</p>
        </div>
        
        <div class="section">
            <h3>How to Play</h3>
            <ul>
                <li>Drag to connect neighboring letters—horizontal, vertical, or diagonal.</li>
                <li>Every valid word must be at least four letters long.</li>
            </ul>
        </div>

        <div class="section">
            <h3>Word Colors</h3>
            <ul>
                <li><strong style="color: #22c55e;">Green</strong> = Cornerstone (find them all to win).</li>
                <li><strong style="color: #3b82f6;">Blue</strong> = Other valid words (score hints).</li>
            </ul>
        </div>

        <div class="section">
            <h3>Hints</h3>
            <ul>
                <li>Each blue word earns <strong>1 hint</strong>.</li>
                <li>Click on unrevealed cornerstone words to spend hints.</li>
                <li>Spend hints to reveal letters or see a word's definition—use them wisely.</li>
            </ul>
        </div>

        <div class="section">
            <h3>Input Mode</h3>
            <p>Choose how you want to select letters:</p>
            <div class="input-mode-toggle">
                <button class="mode-button active" id="dragModeBtn" onclick="game.setInputMode('drag')">
                    <span>Drag</span>
                    <span class="mode-description">Click & drag to select</span>
                </button>
                <button class="mode-button" id="tapModeBtn" onclick="game.setInputMode('tap')">
                    <span>Tap</span>
                    <span class="mode-description">Tap cells one by one</span>
                </button>
            </div>
        </div>

        <button class="close-instructions" onclick="game.closeInstructions()">Got it!</button>
    </div>

    <script>
        // Mobile tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            if (tabName === 'game') {
                document.getElementById('game-tab').classList.add('active');
                document.getElementById('cornerstone-tab').classList.remove('active');
                document.getElementById('cornerstone-tab').classList.remove('mobile-view');
            } else {
                document.getElementById('game-tab').classList.remove('active');
                document.getElementById('cornerstone-tab').classList.add('active');
                document.getElementById('cornerstone-tab').classList.add('mobile-view');
            }
        }

        // Import required data (these will be loaded from external files)
        // The global variables are now properly exported from their respective files

        // Cross-shaped grid layout and adjacency
        const CROSS_POSITIONS = [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14];
        const HAMILTONIAN_PATHS = [
            [1, 5, 4, 8, 9, 13, 14, 10, 6, 2, 7, 11],  // Path 0
            [4, 5, 9, 8, 13, 14, 11, 7, 6, 10, 2, 1],  // Path 1
            [1, 2, 7, 11, 14, 13, 8, 4, 5, 6, 10, 9],  // Path 2
            [5, 1, 2, 6, 10, 14, 13, 9, 8, 4, 7, 11],  // Path 3
            [11, 7, 2, 1, 5, 9, 13, 14, 10, 6, 4, 8],  // Path 4
            [8, 4, 5, 1, 6, 2, 7, 11, 14, 10, 9, 13],  // Path 5
            [9, 5, 4, 8, 13, 14, 10, 6, 1, 2, 7, 11],  // Path 6
            [14, 13, 9, 10, 11, 7, 6, 2, 1, 5, 4, 8],  // Path 7
            [2, 1, 4, 5, 9, 8, 13, 14, 11, 10, 6, 7],  // Path 8
            [7, 11, 10, 14, 9, 13, 8, 4, 5, 1, 2, 6]   // Path 9
        ];
        const SAMPLE_PUZZLES = {
            "CORNERSTONES": { seedWord: "CORNERSTONES", pathIndex: 0 },
            "ARCHITECTURE": { seedWord: "ARCHITECTURE", pathIndex: 1 },
            "EXPERIMENTAL": { seedWord: "EXPERIMENTAL", pathIndex: 2 },
            "TECHNOLOGIES": { seedWord: "TECHNOLOGIES", pathIndex: 3 },
            "CHAMPIONSHIP": { seedWord: "CHAMPIONSHIP", pathIndex: 4 },
            "INTELLIGENCE": { seedWord: "INTELLIGENCE", pathIndex: 5 },
            "NEIGHBORHOOD": { seedWord: "NEIGHBORHOOD", pathIndex: 6 },
            "THANKSGIVING": { seedWord: "THANKSGIVING", pathIndex: 7 },
            "ENCYCLOPEDIA": { seedWord: "ENCYCLOPEDIA", pathIndex: 8 },
            "BREAKTHROUGH": { seedWord: "BREAKTHROUGH", pathIndex: 9 }
        };
        const ADJACENCY = {
            1: [2, 4, 5, 6],
            2: [1, 5, 6, 7],
            4: [1, 5, 8, 9],
            5: [1, 2, 4, 6, 8, 9, 10],
            6: [1, 2, 5, 7, 9, 10, 11],
            7: [2, 6, 10, 11],
            8: [4, 5, 9, 13],
            9: [4, 5, 6, 8, 10, 13, 14],
            10: [5, 6, 7, 9, 11, 13, 14],
            11: [6, 7, 10, 14],
            13: [8, 9, 10, 14],
            14: [9, 10, 11, 13]
        };

        class CornerstonesGame {
            constructor() {
                this.currentPuzzle = "CORNERSTONES";
                this.grid = [];
                this.selectedPath = [];
                this.foundWords = new Set();
                this.allPossibleWords = new Set();
                this.cornerstoneWords = [];
                this.validWords = [];
                this.isSelecting = false;
                this.gameStarted = false;
                this.hintSystem = new HintSystem();
                this.sortAlphabetically = false;
                this.revealLetterMode = false;
                this.letterSelectionWord = null;
                this.definitionRevealMode = false;
                this.cancelHandler = null;
                this.selectedHintWord = null;
                this.hintMenuHandler = null;
                this.isDragging = false;
                this.touchStartTime = 0;
                this.inputMode = 'drag'; // 'drag' or 'tap'
                
                this.initializeGame();
                this.setupEventListeners();
                this.loadInputModePreference();
            }
            
            setInputMode(mode) {
                if (this.inputMode === mode) return;
                
                this.inputMode = mode;
                this.saveInputModePreference();
                this.updateModeButtons();
                this.updateGlobalEventListeners();
                this.recreateGridEventListeners();
                
                // Clear any existing selection when switching modes
                if (this.selectedPath.length > 0) {
                    this.clearSelection();
                }
                
                // Update instructions to reflect new mode
                this.updateCurrentWord();
            }
            
            updateModeButtons() {
                const dragBtn = document.getElementById('dragModeBtn');
                const tapBtn = document.getElementById('tapModeBtn');
                
                if (this.inputMode === 'drag') {
                    dragBtn.classList.add('active');
                    tapBtn.classList.remove('active');
                } else {
                    dragBtn.classList.remove('active');
                    tapBtn.classList.add('active');
                }
            }
            
            saveInputModePreference() {
                localStorage.setItem('cornerstones_input_mode', this.inputMode);
            }
            
            loadInputModePreference() {
                const savedMode = localStorage.getItem('cornerstones_input_mode');
                if (savedMode && ['drag', 'tap'].includes(savedMode)) {
                    this.inputMode = savedMode;
                }
                this.updateModeButtons();
            }
            
            addCellEventListeners(cell) {
                if (this.inputMode === 'drag') {
                    // Drag mode: use mousedown/mouseenter/mouseup for desktop
                    cell.addEventListener('mousedown', (e) => this.startSelection(e));
                    cell.addEventListener('mouseenter', (e) => this.continueSelection(e));
                    cell.addEventListener('mouseup', (e) => this.endSelection(e));
                } else {
                    // Tap mode: use click events only
                    cell.addEventListener('click', (e) => this.handleCellClick(e));
                }
                
                // Touch events for mobile (both modes)
                cell.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                cell.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                cell.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }
            
            recreateGridEventListeners() {
                // Remove all existing event listeners and re-add based on current mode
                const cells = document.querySelectorAll('.cell:not(.empty)');
                cells.forEach(cell => {
                    // Clone node to remove all event listeners
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);
                    this.addCellEventListeners(newCell);
                });
            }

            async initializeGame() {
                this.createGrid();
                this.generatePuzzle();
                await this.findAllPossibleWords();
                this.updateStats();
                this.updateCornerstoneDisplay();
                this.updateHintButtons();
                await this.loadProgress();
            }

            createGrid() {
                const gridElement = document.getElementById('gameGrid');
                gridElement.innerHTML = '';
                
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    
                    if ([0, 3, 12, 15].includes(i)) {
                        cell.classList.add('empty');
                    } else {
                        this.addCellEventListeners(cell);
                    }
                    
                    gridElement.appendChild(cell);
                }
            }

            generatePuzzle() {
                const puzzle = SAMPLE_PUZZLES[this.currentPuzzle];
                const path = HAMILTONIAN_PATHS[puzzle.pathIndex];
                const letters = puzzle.seedWord.split('');
                
                this.grid = new Array(16).fill('');
                
                path.forEach((position, index) => {
                    this.grid[position] = letters[index];
                });
                
                const cells = document.querySelectorAll('.cell:not(.empty)');
                cells.forEach((cell) => {
                    const index = parseInt(cell.dataset.index);
                    cell.textContent = this.grid[index] || '';
                });
            }

            async findAllPossibleWords() {
                this.allPossibleWords = new Set();
                this.cornerstoneWords = [];
                this.validWords = [];
                
                if (!window.COMPREHENSIVE_WORD_SET) {
                    console.error('Word database not loaded!');
                    return;
                }
                console.log(`Word database loaded with ${window.COMPREHENSIVE_WORD_SET.size} words`);
                
                const visited = new Array(16).fill(false);
                
                CROSS_POSITIONS.forEach(startPos => {
                    this.dfsWordSearch(startPos, '', [startPos], visited.slice());
                });
                
                // Get the current puzzle's seed word
                const currentSeedWord = SAMPLE_PUZZLES[this.currentPuzzle].seedWord;
                
                // Classify words as cornerstone or valid
                this.allPossibleWords.forEach(word => {
                    const wordData = {
                        word: word,
                        found: false,
                        revealed: null,
                        pattern: null,
                        showDefinition: false,
                        definition: word === currentSeedWord && SEED_WORDS[currentSeedWord] 
                            ? SEED_WORDS[currentSeedWord].definition 
                            : getDefinition(word)
                    };
                    
                    // Seed word is always a cornerstone word for its puzzle
                    if (word === currentSeedWord || COMMON_WORDS_SET.has(word.toLowerCase())) {
                        this.cornerstoneWords.push(wordData);
                    } else {
                        this.validWords.push(word);
                    }
                });
                
                console.log(`Found ${this.cornerstoneWords.length} cornerstone words and ${this.validWords.length} other valid words`);
            }

            dfsWordSearch(position, currentWord, path, visited) {
                visited[position] = true;
                const newWord = currentWord + this.grid[position];
                
                if (newWord.length >= 4 && window.COMPREHENSIVE_WORD_SET && window.COMPREHENSIVE_WORD_SET.has(newWord.toUpperCase())) {
                    this.allPossibleWords.add(newWord.toUpperCase());
                }
                
                // Continue searching up to 12 letters (to find seed words)
                if (newWord.length <= 12) {
                    const neighbors = ADJACENCY[position] || [];
                    neighbors.forEach(neighbor => {
                        if (!visited[neighbor] && this.grid[neighbor]) {
                            this.dfsWordSearch(neighbor, newWord, [...path, neighbor], visited.slice());
                        }
                    });
                }
            }

            setupEventListeners() {
                // Only add global mouseup in drag mode
                this.globalMouseUpHandler = () => this.endSelection();
                
                document.getElementById('overlay').addEventListener('click', () => this.closeDefinition());
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Handle clicks outside grid cells to submit word (tap mode only)
                this.globalClickHandler = (e) => {
                    if (this.inputMode === 'tap' && !e.target.closest('#gameGrid') && this.selectedPath.length > 0) {
                        this.submitCurrentWord();
                    }
                };
                document.addEventListener('click', this.globalClickHandler);
                
                // Set up mode-specific global listeners
                this.updateGlobalEventListeners();
            }
            
            updateGlobalEventListeners() {
                // Remove existing listeners
                document.removeEventListener('mouseup', this.globalMouseUpHandler);
                
                // Add listeners based on current mode
                if (this.inputMode === 'drag') {
                    document.addEventListener('mouseup', this.globalMouseUpHandler);
                }
            }

            handleTouchStart(e) {
                e.preventDefault();
                this.touchStartTime = Date.now();
                this.isDragging = false;
                // Don't start selection here - wait to see if it's a tap or drag
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                // Start drag selection on first move
                if (!this.isDragging) {
                    this.isDragging = true;
                    const startElement = e.target;
                    if (startElement && startElement.classList.contains('cell')) {
                        this.startSelection({ target: startElement, preventDefault: () => {} });
                    }
                }
                
                // Continue selection
                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                if (element && element.classList.contains('cell')) {
                    this.continueSelection({ target: element });
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                // Only end selection if it was a drag
                if (this.isDragging) {
                    this.endSelection(e);
                }
                // For taps, don't end selection - let the click handler manage it
            }
            
            handleCellClick(e) {
                // Only handle in tap mode
                if (this.inputMode !== 'tap') return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const index = parseInt(e.target.dataset.index);
                
                // If we have a selection in progress
                if (this.selectedPath.length > 0) {
                    const lastIndex = this.selectedPath[this.selectedPath.length - 1];
                    
                    // Check if clicked cell is adjacent to last selected
                    if (this.isAdjacent(lastIndex, index) && !this.selectedPath.includes(index)) {
                        // Add to path
                        this.addToPath(index);
                    } else {
                        // Not adjacent or already in path - submit current word
                        this.submitCurrentWord();
                        
                        // Start new selection if clicked on a valid cell
                        if (!e.target.classList.contains('empty')) {
                            this.selectedPath = [];
                            this.addToPath(index);
                        }
                    }
                } else {
                    // No selection - start new one
                    if (!e.target.classList.contains('empty')) {
                        this.selectedPath = [];
                        this.addToPath(index);
                    }
                }
            }

            startSelection(e) {
                e.preventDefault();
                this.isSelecting = true;
                this.selectedPath = [];
                const index = parseInt(e.target.dataset.index);
                this.addToPath(index);
            }

            continueSelection(e) {
                // Only continue on mouseenter if we're actively dragging (mouse button down)
                if (e.type === 'mouseenter' && !e.buttons) {
                    return;
                }
                
                if (!this.isSelecting) return;
                
                const index = parseInt(e.target.dataset.index);
                this.addToPath(index);
            }

            endSelection(e) {
                if (!this.isSelecting) return;
                this.isSelecting = false;
                this.submitCurrentWord();
            }
            
            submitCurrentWord() {
                const word = this.getSelectedWord();
                
                // Clear selection first, before showing messages
                this.clearSelection();
                
                if (word.length >= 4) {
                    this.checkWord(word);
                } else if (word.length > 0) {
                    this.showMessage('Words must be at least 4 letters', 'error');
                }
            }

            addToPath(index) {
                // Check if we're going back to a previously selected letter
                const existingIndex = this.selectedPath.indexOf(index);
                if (existingIndex !== -1) {
                    // If it's the second-to-last letter, remove the last letter (backtrack)
                    if (existingIndex === this.selectedPath.length - 2) {
                        this.selectedPath.pop(); // Remove the last letter
                        this.updateSelection();
                        this.updateCurrentWord();
                    }
                    // If it's any other previously selected letter, do nothing
                    return;
                }
                
                if (this.selectedPath.length > 0) {
                    const lastIndex = this.selectedPath[this.selectedPath.length - 1];
                    if (!this.isAdjacent(lastIndex, index)) return;
                }
                
                this.selectedPath.push(index);
                this.updateSelection();
                this.updateCurrentWord();
            }

            isAdjacent(pos1, pos2) {
                const neighbors = ADJACENCY[pos1] || [];
                return neighbors.includes(pos2);
            }

            updateSelection() {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected', 'in-path');
                });
                
                this.selectedPath.forEach((index, i) => {
                    const cell = document.querySelector(`[data-index="${index}"]`);
                    if (i === this.selectedPath.length - 1) {
                        cell.classList.add('selected');
                    } else {
                        cell.classList.add('in-path');
                    }
                });
            }

            clearSelection() {
                this.selectedPath = [];
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected', 'in-path');
                });
                
                // Update current word display after clearing selection
                this.updateCurrentWord();
            }

            getSelectedWord() {
                return this.selectedPath.map(index => this.grid[index]).join('').toUpperCase();
            }

            updateCurrentWord() {
                const currentWordEl = document.getElementById('currentWord');
                const word = this.getSelectedWord();
                
                // Don't override messages (they have CSS classes other than 'word-display')
                if (!currentWordEl.className.includes('success') && 
                    !currentWordEl.className.includes('error') && 
                    !currentWordEl.className.includes('cornerstone')) {
                    
                    if (word && word.length > 0) {
                        // Show the selected letters in both modes
                        currentWordEl.textContent = word;
                    } else if (this.letterSelectionWord) {
                        // In letter selection mode - show specific instructions
                        currentWordEl.textContent = 'Click on a letter position to reveal it!';
                    } else {
                        // Show mode-specific instructions when no word is selected
                        if (this.inputMode === 'tap') {
                            currentWordEl.textContent = 'Tap cells to form words';
                        } else {
                            currentWordEl.textContent = 'Drag to form words';
                        }
                    }
                    currentWordEl.className = 'word-display';
                }
            }

            checkWord(word) {
                const upperWord = word.toUpperCase();
                
                if (this.foundWords.has(upperWord)) {
                    this.showMessage(`"${upperWord}" already found!`, 'error');
                    return;
                }
                
                // Check if it's a cornerstone word
                const cornerstoneWord = this.cornerstoneWords.find(w => w.word === upperWord);
                if (cornerstoneWord) {
                    cornerstoneWord.found = true;
                    this.foundWords.add(upperWord);
                    this.showMessage(`Cornerstone word found: "${upperWord}"!`, 'cornerstone');
                    this.updateFoundWords();
                    this.updateStats();
                    this.updateCornerstoneDisplay();
                    this.saveProgress();
                } else if (this.validWords.includes(upperWord)) {
                    // Valid word but not cornerstone - earn a hint
                    this.foundWords.add(upperWord);
                    this.hintSystem.earnHint();
                    this.showMessage(`"${upperWord}" found! +1 hint earned`, 'success');
                    this.updateFoundWords();
                    this.updateStats();
                    this.updateHintButtons();
                    this.updateCornerstoneDisplay(); // Update to make words clickable now that we have hints
                    this.saveProgress();
                } else {
                    this.showMessage('Not a valid word', 'error');
                }
            }

            showMessage(text, type) {
                const currentWordEl = document.getElementById('currentWord');
                const messageEl = document.getElementById('message');
                
                // Show message in the currentWord element
                currentWordEl.textContent = text;
                currentWordEl.className = `word-display ${type}`;
                
                // Also clear the old message element
                messageEl.textContent = '';
                messageEl.className = 'message';
                
                // Clear message after 5 seconds and restore appropriate display
                setTimeout(() => {
                    // Reset the class to allow updateCurrentWord to work
                    currentWordEl.className = 'word-display';
                    this.updateCurrentWord();
                }, 5000);
            }

            showDefinition(word, isCornerstone) {
                document.getElementById('popupWord').textContent = word;
                document.getElementById('popupType').textContent = isCornerstone ? 'Cornerstone Word!' : 'Valid Word';
                document.getElementById('popupType').className = `popup-type ${isCornerstone ? 'cornerstone' : ''}`;
                
                const definition = getDefinition(word);
                document.getElementById('popupDefinition').textContent = definition;
                
                document.getElementById('overlay').classList.add('show');
                document.getElementById('definitionPopup').classList.add('show');
            }

            closeDefinition() {
                document.getElementById('overlay').classList.remove('show');
                document.getElementById('definitionPopup').classList.remove('show');
            }

            showInstructions() {
                document.getElementById('overlay').classList.add('show');
                document.getElementById('instructionsPopup').classList.add('show');
                
                // Add click handler to overlay for closing
                const overlay = document.getElementById('overlay');
                const instructionsClickHandler = (e) => {
                    if (e.target === overlay) {
                        this.closeInstructions();
                    }
                };
                overlay.addEventListener('click', instructionsClickHandler);
                overlay._instructionsClickHandler = instructionsClickHandler;
            }

            closeInstructions() {
                document.getElementById('overlay').classList.remove('show');
                document.getElementById('instructionsPopup').classList.remove('show');
                
                // Remove click handler
                const overlay = document.getElementById('overlay');
                if (overlay._instructionsClickHandler) {
                    overlay.removeEventListener('click', overlay._instructionsClickHandler);
                    delete overlay._instructionsClickHandler;
                }
            }

            updateFoundWords() {
                const wordListEl = document.getElementById('wordList');
                wordListEl.innerHTML = '';
                
                const sortedWords = Array.from(this.foundWords).sort();
                sortedWords.forEach(word => {
                    const wordEl = document.createElement('span');
                    const isCornerstone = this.cornerstoneWords.some(w => w.word === word);
                    wordEl.className = isCornerstone ? 'found-word cornerstone' : 'found-word regular';
                    wordEl.textContent = word;
                    wordEl.onclick = () => this.showDefinition(word, isCornerstone);
                    wordListEl.appendChild(wordEl);
                });
            }

            updateStats() {
                const cornerstoneFound = this.cornerstoneWords.filter(w => w.found).length;
                const totalCornerstone = this.cornerstoneWords.length;
                const totalFound = this.foundWords.size;
                const totalPossible = this.allPossibleWords.size;
                
                document.getElementById('cornerstoneFound').textContent = `${cornerstoneFound}/${totalCornerstone}`;
                document.getElementById('totalFound').textContent = `${totalFound}/${totalPossible}`;
                document.getElementById('hintsAvailable').textContent = this.hintSystem.availableHints;
                
                // Update cornerstone count in panel
                document.getElementById('cornerstoneCount').textContent = `${cornerstoneFound}/${totalCornerstone}`;
                document.getElementById('hintCount').textContent = `${this.hintSystem.availableHints} Available`;
            }

            updateCornerstoneDisplay() {
                const listEl = document.getElementById('cornerstoneList');
                listEl.innerHTML = '';
                
                let displayWords = [...this.cornerstoneWords];
                // Always sort alphabetically
                displayWords.sort((a, b) => a.word.localeCompare(b.word));
                
                displayWords.forEach((wordData, index) => {
                    const wordEl = document.createElement('div');
                    wordEl.className = `cornerstone-word ${wordData.found ? 'found' : 'hidden'}`;
                    
                    let content = '<div>';
                    if (wordData.found) {
                        content += `<span class="cornerstone-word-text">${wordData.word}</span>`;
                    } else if (this.globalLetterRevealMode) {
                        // In global letter reveal mode - create individual clickable letter spans
                        content += '<span class="cornerstone-word-text">';
                        for (let i = 0; i < wordData.word.length; i++) {
                            const letter = wordData.revealed && wordData.revealed[i] ? wordData.word[i] : '_';
                            const isClickable = !wordData.revealed || !wordData.revealed[i];
                            const letterClass = isClickable ? 'clickable-letter-global' : 'revealed-letter-global';
                            content += `<span class="${letterClass}" data-word-index="${index}" data-letter-index="${i}">${letter}</span>`;
                            if (i < wordData.word.length - 1) content += ' ';
                        }
                        content += '</span>';
                    } else if (this.letterSelectionWord === wordData) {
                        // In letter selection mode - maintain compact format like other words
                        const pattern = wordData.word.split('').map((letter, i) => {
                            return wordData.revealed && wordData.revealed[i] ? letter : '_';
                        }).join(' ');
                        content += `<span class="cornerstone-word-text" data-word-index="${index}">${pattern}</span>`;
                    } else if (wordData.pattern) {
                        content += `<span class="cornerstone-word-text">${wordData.pattern}</span>`;
                    } else {
                        const hiddenPattern = '_ '.repeat(wordData.word.length).trim();
                        content += `<span class="cornerstone-word-text">${hiddenPattern}</span>`;
                    }
                    
                    // Always show word length
                    content += `<span class="word-length">(${wordData.word.length} letters)</span>`;
                    
                    content += '</div>';
                    
                    if (wordData.showDefinition || wordData.found) {
                        content += `<div class="word-definition">${wordData.definition}</div>`;
                    }
                    
                    wordEl.innerHTML = content;
                    
                    if (wordData.found) {
                        wordEl.onclick = () => this.showDefinition(wordData.word, true);
                    } else if (this.globalLetterRevealMode) {
                        // In global letter reveal mode, words are not clickable - only individual letters are
                        // Click handling for letters is done in the event delegation below
                    } else if (this.revealLetterMode) {
                        // In reveal letter mode, unfound words are clickable
                        wordEl.classList.add('clickable-hint');
                        wordEl.onclick = () => this.enterLetterSelection(wordData);
                    } else if (this.letterSelectionWord) {
                        // In letter selection mode
                        if (this.letterSelectionWord === wordData) {
                            // This is the currently selected word - make it clickable for letter selection
                            wordEl.classList.add('clickable-hint');
                            // Add a subtle visual indicator that this is the selected word
                            wordEl.style.background = '#f0f8ff';
                        } else if (!wordData.found) {
                            // Other unfound words are clickable to switch selection
                            wordEl.classList.add('clickable-hint');
                            wordEl.onclick = () => this.switchLetterSelection(wordData);
                        }
                    } else if (this.definitionRevealMode) {
                        // In definition reveal mode, unfound words without definitions are clickable
                        if (!wordData.found && !wordData.showDefinition) {
                            wordEl.classList.add('clickable-hint');
                            wordEl.onclick = () => this.revealDefinitionForWord(wordData);
                        }
                    } else {
                        // Default mode - unrevealed words are clickable if player has hints
                        if (!wordData.found && this.hintSystem.availableHints > 0) {
                            // Allow clicking even if definition is shown (user might want to reveal letters)
                            wordEl.classList.add('clickable-hint');
                            wordEl.onclick = (e) => this.showHintOptionsMenu(wordData, e);
                        }
                    }
                    
                    listEl.appendChild(wordEl);
                });

                // Add event delegation for global letter reveal mode
                if (this.globalLetterRevealMode) {
                    const clickableLetters = listEl.querySelectorAll('.clickable-letter-global');
                    clickableLetters.forEach(letterEl => {
                        letterEl.onclick = (e) => {
                            e.stopPropagation(); // Prevent word click
                            const wordIndex = parseInt(letterEl.dataset.wordIndex);
                            const letterIndex = parseInt(letterEl.dataset.letterIndex);
                            const wordData = displayWords[wordIndex];
                            this.revealLetterAtPosition(wordData, letterIndex);
                        };
                    });
                }
                
                // Add event delegation for the currently selected word in letter selection mode
                if (this.letterSelectionWord) {
                    const selectedWordElement = Array.from(listEl.querySelectorAll('.cornerstone-word')).find(wordEl => {
                        const wordText = wordEl.querySelector('.cornerstone-word-text');
                        return wordText && wordText.hasAttribute('data-word-index');
                    });
                    
                    if (selectedWordElement) {
                        const wordText = selectedWordElement.querySelector('.cornerstone-word-text');
                        wordText.onclick = (e) => {
                            e.stopPropagation(); // Prevent word click
                            
                            // Calculate which letter position was clicked
                            const rect = wordText.getBoundingClientRect();
                            const clickX = e.clientX - rect.left;
                            const letterCount = this.letterSelectionWord.word.length;
                            
                            // Estimate letter position based on click position
                            const letterWidth = rect.width / letterCount;
                            const letterIndex = Math.floor(clickX / letterWidth);
                            
                            // Ensure valid range
                            const validIndex = Math.max(0, Math.min(letterIndex, letterCount - 1));
                            
                            // Only allow clicking on unrevealed letters
                            if (!this.letterSelectionWord.revealed || !this.letterSelectionWord.revealed[validIndex]) {
                                this.revealLetterAtPosition(this.letterSelectionWord, validIndex);
                            } else {
                                this.showMessage('That letter is already revealed!', 'error');
                            }
                        };
                    }
                }
            }

            updateHintButtons() {
                const hints = this.hintSystem.availableHints;
                
                // Enable/disable buttons
                document.getElementById('revealLetterBtn').disabled = hints < 1 || 
                    this.cornerstoneWords.every(w => w.found);
                document.getElementById('showDefinitionBtn').disabled = hints < 1 || 
                    this.cornerstoneWords.every(w => w.found);
            }

            useHintRevealLetter() {
                // Check if player has enough hints
                if (!this.hintSystem.canUseHint(1)) {
                    this.showMessage('Not enough hints!', 'error');
                    return;
                }

                // Find unfound cornerstone words
                const unfoundWords = this.cornerstoneWords.filter(w => !w.found);
                if (unfoundWords.length === 0) {
                    this.showMessage('All cornerstone words found!', 'error');
                    return;
                }

                // Enter reveal letter mode
                this.revealLetterMode = true;
                this.showMessage('Click on a cornerstone word to choose which letter to reveal!', 'success');
                this.updateCornerstoneDisplay(); // Refresh to show clickable state
                this.addCancelHandler(); // Allow canceling by clicking elsewhere
            }

            enterLetterSelection(wordData) {
                // Exit reveal letter mode and enter letter selection mode
                this.revealLetterMode = false;
                this.letterSelectionWord = wordData;
                
                // Initialize revealed array if needed
                if (!wordData.revealed) {
                    wordData.revealed = new Array(wordData.word.length).fill(false);
                }

                // Check if all letters are already revealed
                if (wordData.revealed.every(revealed => revealed)) {
                    this.showMessage('All letters in that word are already revealed!', 'error');
                    this.letterSelectionWord = null;
                    this.updateCornerstoneDisplay();
                    this.removeCancelHandler();
                    return;
                }

                this.showMessage('Click on a letter position to reveal it, or click another word to switch!', 'success');
                this.updateCornerstoneDisplay();
                // Cancel handler is already added from reveal letter mode, no need to add again
            }

            switchLetterSelection(wordData) {
                // Switch to a different word for letter selection
                this.letterSelectionWord = wordData;
                
                // Initialize revealed array if needed
                if (!wordData.revealed) {
                    wordData.revealed = new Array(wordData.word.length).fill(false);
                }

                // Check if all letters are already revealed
                if (wordData.revealed.every(revealed => revealed)) {
                    this.showMessage('All letters in that word are already revealed!', 'error');
                    this.letterSelectionWord = null;
                    this.updateCornerstoneDisplay();
                    this.removeCancelHandler();
                    return;
                }

                this.showMessage('Click on a letter position to reveal it, or click another word to switch!', 'success');
                this.updateCornerstoneDisplay();
            }

            addCancelHandler() {
                // Add click handler to cancel letter selection when clicking elsewhere
                if (!this.cancelHandler) {
                    this.cancelHandler = (e) => {
                        // Don't cancel if clicking on cornerstone words, hint buttons, or hint menu
                        if (!e.target.closest('.cornerstone-word') && 
                            !e.target.closest('.hint-button') &&
                            !e.target.closest('#hintOptionsMenu')) {
                            this.cancelLetterSelection();
                        }
                    };
                }
                // Delay adding the handler to avoid immediate triggering
                setTimeout(() => {
                    document.addEventListener('click', this.cancelHandler);
                }, 100);
            }

            removeCancelHandler() {
                if (this.cancelHandler) {
                    document.removeEventListener('click', this.cancelHandler);
                }
            }

            cancelLetterSelection() {
                const wasDefinitionMode = this.definitionRevealMode;
                const wasGlobalLetterMode = this.globalLetterRevealMode;
                this.letterSelectionWord = null;
                this.revealLetterMode = false;
                this.definitionRevealMode = false;
                this.globalLetterRevealMode = false;
                const message = wasDefinitionMode ? 'Definition reveal cancelled' : 'Letter reveal cancelled';
                this.showMessage(message, 'error');
                this.updateCornerstoneDisplay();
                this.removeCancelHandler();
            }

            revealLetterAtPosition(wordData, letterIndex) {
                // Exit letter selection modes
                this.letterSelectionWord = null;
                this.globalLetterRevealMode = false;
                this.removeCancelHandler();
                
                // Use hints
                if (!this.hintSystem.useHints(1)) {
                    this.showMessage('Not enough hints!', 'error');
                    this.updateCornerstoneDisplay();
                    return;
                }

                // Check if letter is already revealed
                if (wordData.revealed[letterIndex]) {
                    this.showMessage('That letter is already revealed!', 'error');
                    // Refund the hint
                    this.hintSystem.availableHints++;
                    this.updateCornerstoneDisplay();
                    return;
                }

                // Reveal the letter
                wordData.revealed[letterIndex] = true;
                
                // Update pattern
                wordData.pattern = wordData.word.split('').map((letter, index) => {
                    if (wordData.revealed[index]) return letter;
                    return '_';
                }).join(' ');

                this.showMessage('Letter revealed!', 'success');
                this.updateCornerstoneDisplay();
                this.updateStats();
                this.updateHintButtons();
                this.saveProgress();
            }

            useHintShowDefinition() {
                // Check if player has enough hints
                if (!this.hintSystem.canUseHint(1)) {
                    this.showMessage('Not enough hints!', 'error');
                    return;
                }

                // Find unfound cornerstone words
                const unfoundWords = this.cornerstoneWords.filter(w => !w.found && !w.showDefinition);
                if (unfoundWords.length === 0) {
                    this.showMessage('All definitions already revealed!', 'error');
                    return;
                }

                // Enter definition reveal mode
                this.definitionRevealMode = true;
                this.showMessage('Click on a cornerstone word to reveal its definition!', 'success');
                this.updateCornerstoneDisplay(); // Refresh to show clickable state
                this.addCancelHandler(); // Allow canceling by clicking elsewhere
            }

            revealDefinitionForWord(wordData) {
                console.log('revealDefinitionForWord called for:', wordData);
                // Use hints
                if (!this.hintSystem.useHints(1)) {
                    this.showMessage('Not enough hints!', 'error');
                    this.definitionRevealMode = false;
                    this.updateCornerstoneDisplay();
                    this.removeCancelHandler();
                    return;
                }

                // Reveal the definition
                wordData.showDefinition = true;
                this.definitionRevealMode = false;
                this.removeCancelHandler();
                this.showMessage('Definition revealed!', 'success');
                console.log('Definition revealed for:', wordData.word);
                this.updateCornerstoneDisplay();
                this.updateStats();
                this.updateHintButtons();
                this.saveProgress();
            }

            async switchPuzzle() {
                this.currentPuzzle = this.currentPuzzle === "CORNERSTONES" ? "ARCHITECTURE" : "CORNERSTONES";
                this.foundWords.clear();
                this.hintSystem = new HintSystem();
                this.generatePuzzle();
                await this.findAllPossibleWords();
                this.updateFoundWords();
                this.updateStats();
                this.updateCornerstoneDisplay();
                this.updateHintButtons();
                this.clearSelection();
                this.saveProgress();
            }

            newGame() {
                this.foundWords.clear();
                this.hintSystem = new HintSystem();
                this.revealLetterMode = false;
                this.letterSelectionWord = null;
                this.definitionRevealMode = false;
                this.removeCancelHandler(); // Remove cancel handler
                this.closeHintOptionsMenu(); // Close hint menu if open
                this.cornerstoneWords.forEach(w => {
                    w.found = false;
                    w.revealed = null;
                    w.pattern = null;
                    w.showDefinition = false;
                });
                this.updateFoundWords();
                this.updateStats();
                this.updateCornerstoneDisplay();
                this.updateHintButtons();
                this.clearSelection();
                this.saveProgress();
            }

            saveProgress() {
                const progress = {
                    puzzle: this.currentPuzzle,
                    foundWords: Array.from(this.foundWords),
                    cornerstoneWords: this.cornerstoneWords,
                    hintState: this.hintSystem.saveState(),
                    sortAlphabetically: this.sortAlphabetically,
                    date: new Date().toDateString()
                };
                localStorage.setItem('cornerstonesProgress', JSON.stringify(progress));
            }

            showHintOptionsMenu(wordData, event) {
                event.stopPropagation();
                this.selectedHintWord = wordData;
                
                const menu = document.getElementById('hintOptionsMenu');
                const rect = event.target.getBoundingClientRect();
                
                // Show the menu first to get accurate dimensions
                menu.classList.add('show');
                
                // Disable definition button if definition is already shown
                const definitionBtn = document.getElementById('hintRevealDefinitionOption');
                if (wordData.showDefinition) {
                    definitionBtn.disabled = true;
                    definitionBtn.style.opacity = '0.5';
                    definitionBtn.style.cursor = 'not-allowed';
                } else {
                    definitionBtn.disabled = false;
                    definitionBtn.style.opacity = '1';
                    definitionBtn.style.cursor = 'pointer';
                }
                
                // Position the menu near the clicked word
                menu.style.left = rect.left + 'px';
                menu.style.top = (rect.bottom + 10) + 'px';
                
                // Adjust if menu goes off screen
                setTimeout(() => {
                    const menuRect = menu.getBoundingClientRect();
                    if (menuRect.right > window.innerWidth) {
                        menu.style.left = (window.innerWidth - menuRect.width - 20) + 'px';
                    }
                    if (menuRect.bottom > window.innerHeight) {
                        menu.style.top = (rect.top - menu.offsetHeight - 10) + 'px';
                    }
                }, 0);
                
                // Add click handler to close menu when clicking elsewhere
                this.addHintMenuHandler();
            }
            
            addHintMenuHandler() {
                if (!this.hintMenuHandler) {
                    this.hintMenuHandler = (e) => {
                        // Don't close if clicking on the menu or its children
                        if (!e.target.closest('#hintOptionsMenu') && !e.target.closest('.cornerstone-word')) {
                            this.closeHintOptionsMenu();
                        }
                    };
                }
                // Use a longer timeout to ensure button handlers are set first
                setTimeout(() => {
                    document.addEventListener('click', this.hintMenuHandler, true);
                }, 100);
            }
            
            closeHintOptionsMenu() {
                document.getElementById('hintOptionsMenu').classList.remove('show');
                if (this.hintMenuHandler) {
                    document.removeEventListener('click', this.hintMenuHandler);
                }
                this.selectedHintWord = null;
            }
            
            selectHintOption(optionType) {
                console.log('selectHintOption called with:', optionType, this.selectedHintWord);
                
                if (!this.selectedHintWord) {
                    console.log('No selected hint word!');
                    return;
                }
                
                // Store the selected word before closing menu
                const wordData = this.selectedHintWord;
                this.closeHintOptionsMenu();
                
                // Check if player has enough hints
                if (!this.hintSystem.canUseHint(1)) {
                    this.showMessage('Not enough hints!', 'error');
                    return;
                }
                
                if (optionType === 'letter') {
                    // Enter global letter reveal mode - all letters in all words become clickable
                    this.globalLetterRevealMode = true;
                    this.letterSelectionWord = null; // Clear any specific word selection
                    
                    // Initialize revealed arrays for all words if needed
                    this.cornerstoneWords.forEach(word => {
                        if (!word.found && !word.revealed) {
                            word.revealed = new Array(word.word.length).fill(false);
                        }
                    });
                    
                    this.showMessage('Click on any letter position in any word to reveal it!', 'success');
                    this.updateCornerstoneDisplay();
                    this.addCancelHandler();
                } else if (optionType === 'definition') {
                    // Reveal definition for this word
                    this.revealDefinitionForWord(wordData);
                }
            }

            async loadProgress() {
                const saved = localStorage.getItem('cornerstonesProgress');
                if (saved) {
                    const progress = JSON.parse(saved);
                    if (progress.date === new Date().toDateString()) {
                        this.currentPuzzle = progress.puzzle;
                        this.foundWords = new Set(progress.foundWords);
                        this.generatePuzzle();
                        await this.findAllPossibleWords();
                        
                        // Restore cornerstone word states
                        if (progress.cornerstoneWords) {
                            progress.cornerstoneWords.forEach(saved => {
                                const word = this.cornerstoneWords.find(w => w.word === saved.word);
                                if (word) {
                                    Object.assign(word, saved);
                                }
                            });
                        }
                        
                        this.hintSystem.loadState(progress.hintState);
                        this.sortAlphabetically = progress.sortAlphabetically || false;
                        
                        this.updateFoundWords();
                        this.updateStats();
                        this.updateCornerstoneDisplay();
                        this.updateHintButtons();
                    }
                }
            }
        }

        // Initialize the game when page loads
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new CornerstonesGame();
            window.game = game; // Make game accessible globally
            
            // Show instructions for first-time users
            const hasPlayedBefore = localStorage.getItem('cornerstones_played');
            if (!hasPlayedBefore) {
                game.showInstructions();
                localStorage.setItem('cornerstones_played', 'true');
            }
        });
    </script>
</body>
</html>